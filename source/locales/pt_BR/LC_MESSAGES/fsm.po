# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, IndieGabo
# This file is distributed under the same license as the IndieGabo's Handy
# Tools package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: IndieGabo's Handy Tools \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-04 13:23-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.1\n"

#: ../../source/fsm/api/actor.rst:4
msgid "Actor"
msgstr ""

#: ../../source/fsm/api/actor.rst:7 ../../source/fsm/api/state-machine.rst:7
#: ../../source/fsm/api/state-transition.rst:7 ../../source/fsm/api/state.rst:7
msgid "Namespace"
msgstr ""

#: ../../source/fsm/api/actor.rst:14 ../../source/fsm/api/state-machine.rst:14
#: ../../source/fsm/api/state-transition.rst:14
#: ../../source/fsm/api/state.rst:14
msgid "Declaration"
msgstr ""

#: ../../source/fsm/api/actor.rst:22 ../../source/fsm/api/state-machine.rst:22
#: ../../source/fsm/api/state.rst:22
msgid "Fields"
msgstr ""

#: ../../source/fsm/api/actor.rst:29 ../../source/fsm/api/state.rst:31
msgid "``protected StateMachine``"
msgstr ""

#: ../../source/fsm/api/actor.rst:29
msgid "``stateMachine``"
msgstr ""

#: ../../source/fsm/api/actor.rst:29
msgid ""
"An internal reference for the actor's :ref:`StateMachine <state-machine-"
"class>`"
msgstr ""

#: ../../source/fsm/api/actor.rst:33 ../../source/fsm/api/state-machine.rst:43
#: ../../source/fsm/api/state-transition.rst:22
#: ../../source/fsm/api/state.rst:37
msgid "Properties"
msgstr ""

#: ../../source/fsm/api/actor.rst:40
msgid "``public StateMachine { get; }``"
msgstr ""

#: ../../source/fsm/api/actor.rst:40
msgid "``Machine``"
msgstr ""

#: ../../source/fsm/api/actor.rst:40
msgid "A public access for the actor's :ref:`StateMachine <state-machine-class>`"
msgstr ""

#: ../../source/fsm/api/actor.rst:44 ../../source/fsm/api/state-machine.rst:64
#: ../../source/fsm/api/state.rst:50
msgid "Methods"
msgstr ""

#: ../../source/fsm/api/actor.rst:51 ../../source/fsm/api/state-machine.rst:75
#: ../../source/fsm/api/state-machine.rst:89 ../../source/fsm/api/state.rst:61
#: ../../source/fsm/api/state.rst:65
msgid "``protected virtual void``"
msgstr ""

#: ../../source/fsm/api/actor.rst:51
msgid "``SetMachine()``"
msgstr ""

#: ../../source/fsm/api/actor.rst:51
msgid ""
"Must be called internally at ``MonoBehaviour.Awake()`` in order to setup "
"the :ref:`StateMachine <state-machine-class>`"
msgstr ""

#: ../../source/fsm/api/actor.rst:-1 ../../source/fsm/api/state-machine.rst:-1
#: ../../source/fsm/api/state-transition.rst:-1
#: ../../source/fsm/api/state.rst:-1
#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:-1
#: ../../source/fsm/how-to-use/parent-states.rst:-1
#: ../../source/fsm/how-to-use/setting-up-an-actor.rst:-1
#: ../../source/fsm/how-to-use/using-the-state-machine.rst:-1
#: ../../source/fsm/welcome.rst:-1
msgid "Gabinho Waving"
msgstr ""

#: ../../source/fsm/api/state.rst:4
msgid "State"
msgstr ""

#: ../../source/fsm/api/state.rst:29
msgid "``new protected string``"
msgstr ""

#: ../../source/fsm/api/state.rst:29
msgid "``name``"
msgstr ""

#: ../../source/fsm/api/state.rst:29
msgid ""
"A name you can give the state (you can use the inspector) |br| so you can"
" have a visual feeeback at the :ref:`StateMachine <state-machine-class>` "
"inspector"
msgstr ""

#: ../../source/fsm/api/state.rst:31
msgid "``machine``"
msgstr ""

#: ../../source/fsm/api/state.rst:31
msgid ""
"The state machine. Set inside InternalLoad() method wich is called by the"
" machine."
msgstr ""

#: ../../source/fsm/api/state.rst:33
msgid "``protected Actor``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:50 ../../source/fsm/api/state.rst:33
msgid "``actor``"
msgstr ""

#: ../../source/fsm/api/state.rst:33
msgid ""
"The machine's actor. Set inside InternalLoad() method wich is called by "
"the machine."
msgstr ""

#: ../../source/fsm/api/state.rst:44
msgid "``public List<StateTransition> { get; protected set; }``"
msgstr ""

#: ../../source/fsm/api/state.rst:44
msgid "``transitions``"
msgstr ""

#: ../../source/fsm/api/state.rst:44
msgid "List of transitions for this state."
msgstr ""

#: ../../source/fsm/api/state.rst:46
msgid "``public string { get; }``"
msgstr ""

#: ../../source/fsm/api/state.rst:46
msgid "``Name``"
msgstr ""

#: ../../source/fsm/api/state.rst:46
msgid "Either the set ``name`` or the state ``Type``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:71
#: ../../source/fsm/api/state-machine.rst:77
#: ../../source/fsm/api/state-machine.rst:79
#: ../../source/fsm/api/state-machine.rst:81
#: ../../source/fsm/api/state-machine.rst:83
#: ../../source/fsm/api/state-machine.rst:85
#: ../../source/fsm/api/state-machine.rst:93
#: ../../source/fsm/api/state-machine.rst:97
#: ../../source/fsm/api/state-machine.rst:99
#: ../../source/fsm/api/state-machine.rst:101 ../../source/fsm/api/state.rst:57
#: ../../source/fsm/api/state.rst:59
msgid "``public virtual void``"
msgstr ""

#: ../../source/fsm/api/state.rst:57
msgid "``InternalLoad``"
msgstr ""

#: ../../source/fsm/api/state.rst:57
msgid ""
"Called by the :ref:`StateMachine <state-machine-class>` to load important"
" functionalities."
msgstr ""

#: ../../source/fsm/api/state.rst:59
msgid "``SortTransitions``"
msgstr ""

#: ../../source/fsm/api/state.rst:59
msgid "Reorders ``transitions`` considering priority levels"
msgstr ""

#: ../../source/fsm/api/state.rst:61 ../../source/fsm/api/state.rst:65
msgid "``AddTransition()``"
msgstr ""

#: ../../source/fsm/api/state.rst:61 ../../source/fsm/api/state.rst:65
msgid ""
"Called to register a :ref:`StateTransition <state-transition-class>`. "
"Must be called inside ``State.OnLoad()``"
msgstr ""

#: ../../source/fsm/api/state.rst:63
msgid "Arguments: ``Func<bool> Condition``, ``State state``, ``int priority = 0``"
msgstr ""

#: ../../source/fsm/api/state.rst:67
msgid "Arguments: ``StateTransition transition``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:4
msgid "State Machine"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:29
#: ../../source/fsm/api/state-machine.rst:33
msgid "``protected string``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:29
msgid "``recognizedActorName``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:29
msgid ""
"The actor related to this state machine |br| just for visual feedback at "
"the inspector"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:31
msgid "``protected MachineStatus``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:31
msgid "``status``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:31
msgid "The machine current status"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:33
msgid "``currentStateName``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:33
msgid "A visual feedback for inspector"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:35
msgid "``protected State``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:35
msgid "``defaultState``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:35
msgid "The default state to be set using inspector"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:37
#: ../../source/fsm/api/state-machine.rst:39
msgid "``protected List<State>``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:37
msgid "``recognizedStates``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:37
msgid "Visual feedback"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:39
msgid "``states``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:39
msgid ""
"List of states attached to the machine's GameObject. |br| Will be loaded "
"at ``StateMachine.SetUp()``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:50
msgid "``public Actor { get; }``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:50
msgid ""
"The state machine's actor instance. |br| This is set in the Machine's "
"SetUp method."
msgstr ""

#: ../../source/fsm/api/state-machine.rst:52
msgid "``public MachineStatus { get; }``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:52
msgid "``Status``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:52
msgid "A getter for the machine's status"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:54
msgid "``public State { get; protected set; }``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:54
msgid "``currentState``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:54
msgid "The machine's current state"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:56
#: ../../source/fsm/api/state-machine.rst:60
msgid "``public State { get; }``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:56
msgid "``DefaultState``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:56
msgid "A getter for ``defaultState``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:58
msgid "``public List<State> { get; }``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:58
msgid "``AttachedStates``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:58
msgid "The list of attached states"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:60
msgid "``RecognizedActor``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:60
msgid ""
"The machine's actor. Either attached to |br| the machine's GameObject or "
"a parent"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:71
msgid "``SetUp()``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:71
msgid "Called by the :ref:`Actor <actor-class>` to initialize the machine"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:73
msgid "Arguments: ``Actor actor``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:75
msgid "``LoadStates()``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:75
msgid "Loads all states attached into the machine's GameObject."
msgstr ""

#: ../../source/fsm/api/state-machine.rst:77
msgid "``StartMachine()``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:77
msgid ""
"If the machine is ready, sets the ``currentState`` to de default state "
"and ``status`` to ``On``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:79
msgid "``Resume()``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:79
msgid "``status`` = ``On``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:81
msgid "``Pause()``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:81
msgid "``status`` = ``Pause``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:83
msgid "``Stop()``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:83
msgid "``status`` = ``Off``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:85
msgid "``ChangeState()``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:85
msgid "Sets the ``currentState`` as the given state"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:87
msgid "Arguments: ``State state``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:89
msgid "``EvaluateNextState()``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:89
msgid ""
"Case any condition of the ``currentState`` :ref:`transitions <state-"
"transition-class>` is met, |br| the machine will transition into the "
"target state"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:91
msgid "``protected virtual State``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:91
msgid "``ConditionMet()``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:91
msgid ""
"Checks the ``StateTransition.Condition()`` of all ``State.transitions`` "
"of the ``currentState``. Returns null if no condition is met."
msgstr ""

#: ../../source/fsm/api/state-machine.rst:93
msgid "``SetDefaultState()``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:93
msgid "Sets the ``defaultState``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:95
msgid "Arguments: ``T`` where ``T`` : ``State``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:97
msgid "``Tick()``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:97
msgid ""
"Called every  :ref:`Actor <actor-class>` ``MonoBehaviour.Update()``. "
"Forces machine to |br| evaluate if should change the ``currentState`` and"
" calls |br| the ``currentState`` ``State.Tick()``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:99
msgid "``LateTick()``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:99
msgid ""
"Called every  :ref:`Actor <actor-class>` ``MonoBehaviour.LateUpdate()``. "
"Forces machine to |br| evaluate if should change the ``currentState`` and"
" calls |br| the ``currentState`` ``State.LateTick()``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:101
msgid "``FixedTick()``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:101
msgid ""
"Called every  :ref:`Actor <actor-class>` ``MonoBehaviour.FixedUpdate()``."
" Forces machine to |br| evaluate if should change the ``currentState`` "
"and calls |br| the ``currentState`` ``State.FixedTick()``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:106
msgid "Events"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:112
msgid "``public UnityEvent<State>``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:112
msgid "``StateChanged``"
msgstr ""

#: ../../source/fsm/api/state-machine.rst:112
msgid "Invoked every time the machine changes the ``currentState``"
msgstr ""

#: ../../source/fsm/api/state-transition.rst:4
msgid "State Transition"
msgstr ""

#: ../../source/fsm/api/state-transition.rst:29
msgid "``public Func<bool> {get; protected set;}``"
msgstr ""

#: ../../source/fsm/api/state-transition.rst:29
msgid "``Condition``"
msgstr ""

#: ../../source/fsm/api/state-transition.rst:29
msgid "A delegate function representing the transition's condition"
msgstr ""

#: ../../source/fsm/api/state-transition.rst:31
msgid "``public State {get; protected set;}``"
msgstr ""

#: ../../source/fsm/api/state-transition.rst:31
msgid "``state``"
msgstr ""

#: ../../source/fsm/api/state-transition.rst:31
msgid "The state wich should be transitioned into based on ``Condition``"
msgstr ""

#: ../../source/fsm/api/state-transition.rst:33
msgid "``public int {get; protected set;}``"
msgstr ""

#: ../../source/fsm/api/state-transition.rst:33
msgid "``priority``"
msgstr ""

#: ../../source/fsm/api/state-transition.rst:33
msgid "The execution priority. Higher numbers first. Default 0."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:4
msgid "Creating States for an Actor"
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:7
msgid "What is a state?"
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:9
msgid ""
"A state represents a specific group of actions that should be performed "
"while an actor's specific condition is met."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:12
msgid "The usage strategy"
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:14
msgid ""
"After being correctly crafted, a :ref:`State <state-class>` script should"
" be attached to the same GameObject as the :ref:`StateMachine <state-"
"machine-class>`. The machine will then automatically recognize it and use"
" it as it should."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:17
msgid ""
"Also, the :ref:`State <state-class>` class, as the :ref:`Actor <actor-"
"class>` class, is abstract. It is so because a state is specific for an "
"specific actor. Being that way, it does not make any sense to a state to "
"exist without knowing its reason for being."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:29
msgid "The code"
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:31
msgid ""
"Below is the base code for a successful state. Take a look at it and feel"
" free to copy and use it as you wish."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:79
msgid ""
"And, of course, there is a Script Template ready for you at *Create* "
"``->`` *IndieGabo* ``->`` *FSM* ``->`` *New State*."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:89
msgid ""
"Ok. Now that we've seen the code, let's take a deep dive into each of "
"those methods. All these methods are optional and you only need to "
"implement the ones you will use inside your state."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:93
msgid "OnLoad()"
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:95
msgid ""
"This method represents the moment a :ref:`StateMachine <state-machine-"
"class>` loads this :ref:`State <state-class>` script into its handled "
"states. So it is inside the ``State.OnLoad()`` that you should put any "
"logic regardind initialization **before** the machine starts running."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:112
msgid ""
"The ``State.OnLoad()`` is the best place to register transitions. Wich we"
" will cover on the :ref:`Transitioning Between States <transitioning-"
"between-states>` section."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:115
msgid ""
"This method is called only once in the :ref:`StateMachine <state-machine-"
"class>` life cycle."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:118
msgid "OnEnter()"
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:120
msgid ""
"This method is called the **exact moment** a :ref:`StateMachine <state-"
"machine-class>` sets this :ref:`State <state-class>` script as its "
"current state."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:133
msgid ""
"The ``State.OnEnter()`` is perfect for start playing animations, "
"initializing variables, properties and etc."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:136
msgid "OnExit()"
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:138
msgid ""
"This method is called **right before** a :ref:`StateMachine <state-"
"machine-class>` wich has this :ref:`State <state-class>` script as its "
"current state, transition into another state."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:152
msgid ""
"The ``State.OnExit()`` is perfect place to stop animations and reset "
"variables, properties and etc."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:155
msgid "Tickers"
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:157
msgid ""
"Once a State is defined as current state by the machine, its \"Ticker "
"methods\" will be called at each time its actor \"frame handlers\" are "
"executed."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:160
msgid "They are:"
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:162
msgid ""
"``Tick()``: Called every time the actor `Update() "
"<https://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html>`_ "
"method is called."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:163
msgid ""
"``LateTick()``: Called every time the actor `LateUpdate() "
"<https://docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html>`_"
" method is called."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:164
msgid ""
"``FixedTick()``: Called every time the actor `FixedUpdate() "
"<https://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html>`_"
" method is called."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:197
msgid ""
"If you are not familiar with the `LateUpdate() "
"<https://docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html>`_"
" method, it is called once per frame after the `Update() "
"<https://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html>`_ as"
" a way to organize your script execution."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:200
msgid ""
"Refer to the :ref:`IndieGabo's FSM Life Cycle <lifecycle>` for visual "
"information about Tickers being called."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:205
msgid "Transitioning Between States"
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:207
msgid "There are two ways for a state to transition into another state:"
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:209
msgid "By calling the Machine's ``ChangeState()`` method."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:213
msgid ""
"As seen on the :ref:`State Documentation <state-class>`, all the states "
"hold reference to the Machine they belong to. Therefore, accessing the "
"machine's methods from within a state is as easy as using its "
"``State.machine`` property as we can see below."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:233
msgid ""
"By registering a :ref:`StateTransition <state-transition-class>` inside "
"its ``State.OnLoad()`` using the ``State.AddTransition()`` method."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:235
msgid ""
"Using this approach (wich is highly recommended) the machine will, at "
"each of the \"frame handlers\", evaluate if any condition is met "
"considering given priorities. If so, it will automatically transition "
"into the target state."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:238
msgid ""
"A :ref:`StateTransition <state-transition-class>` consists in a "
"``Condition``, a target ``State`` and a ``priotity`` level. But there is "
"no need for you to instantiate it. Just call the "
"``State.AddTransition()`` method and pass the those 3 arguments. I take "
"care of the rest for you. Here is how you use it:"
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:250
msgid ""
"But, if you somehow prefer, here is how a StateTransition is instantiated"
" and registered:"
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:261
msgid ""
"Note that to declare a ``Condition`` you **MUST** approach using a "
"`Func<TResult> Delegate <https://docs.microsoft.com/en-"
"us/dotnet/api/system.func-1?view=net-6.0>`_. Do not worry if you are not "
"familiar with this yet. All you need to know is that the machine will "
"call this as a method (function) and its context will be evaluated as "
"true or false only when the machine do so. In case this represents news "
"for you, for now, just follow the syntax in the code below each time you "
"want to register a :ref:`StateTransition <state-transition-class>` in a "
"state."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:267
msgid ""
"To declare the target state, since all states are components attached to "
"the same GameObject, you can just use the ``GetComponent<State>()`` "
"method."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:269
msgid ""
"At last, priority for the machine is read **descending**. Wich means the "
"higher the integer you give as third argument, sooner its condition will "
"be evaluated. otherwise it will be read as the declaration order. The "
"default priority value is ``0``."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:293
msgid ""
"The ``State.OnLoad()`` is called only once on the Machine's life cycle. "
"Meaning that any ``GetComponent<State>()`` (or, well... anything else) "
"used inside of it will not be called multiple times."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:297
msgid "The inspector"
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:299
msgid ""
"For a simple state, a simple name. Just that. You can set a Name for your"
" state using Unity's inspector so you get some better visual feedback "
"when taking a look at the state machine."
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:302
msgid "Set a name:"
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:-1
msgid "State Name on inspector"
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:307
msgid "And see it in action while inpecting the StateMachine:"
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:-1
msgid "State Name appearing on machine"
msgstr ""

#: ../../source/fsm/how-to-use/creating-states-for-an-actor.rst:312
msgid ""
"That is it about creating a state for now. Let me show you a little about"
" :ref:`how to use <using-the-state-machine-class>` our precious state "
"machine."
msgstr ""

#: ../../source/fsm/how-to-use/parent-states.rst:4
msgid "Parent States"
msgstr ""

#: ../../source/fsm/how-to-use/parent-states.rst:7
msgid "Wait a minute... parents?"
msgstr ""

#: ../../source/fsm/how-to-use/parent-states.rst:9
msgid "Yes! Parents!"
msgstr ""

#: ../../source/fsm/how-to-use/parent-states.rst:11
msgid ""
"You can create a state wich holds the same group of properties and "
"functionalities for several other child states."
msgstr ""

#: ../../source/fsm/how-to-use/parent-states.rst:13
msgid ""
"Say you understand that some actor of yours has several states wich can "
"transition into the same other states. Or share a single or even a group "
"of properties. You can create a parent state and then create child states"
" that inherit from that. Like the following example:"
msgstr ""

#: ../../source/fsm/how-to-use/parent-states.rst:16
msgid "First, create a parent state:"
msgstr ""

#: ../../source/fsm/how-to-use/parent-states.rst:42
msgid "Now we can create a GroundedState wich will inherit all those transitions:"
msgstr ""

#: ../../source/fsm/how-to-use/parent-states.rst:54
msgid "But say you need to register new transitions for your child state:"
msgstr ""

#: ../../source/fsm/how-to-use/parent-states.rst:70
msgid ""
"For me personally i find this quite handy. Tons of code can be avoided "
"and you keep your project organized."
msgstr ""

#: ../../source/fsm/how-to-use/setting-up-an-actor.rst:4
msgid "Setting up an Actor"
msgstr ""

#: ../../source/fsm/how-to-use/setting-up-an-actor.rst:7
msgid "What is an Actor?"
msgstr ""

#: ../../source/fsm/how-to-use/setting-up-an-actor.rst:9
msgid ""
"Anything that performs several actions and therefore will benefit from an"
" :ref:`StateMachine <state-machine-class>` handling its states of action,"
" fits the concept of an actor for us."
msgstr ""

#: ../../source/fsm/how-to-use/setting-up-an-actor.rst:11
msgid ""
"That being said, the :ref:`Actor <actor-class>` class exists to be the "
"gateway between the :ref:`StateMachine <state-machine-class>` and any "
"other components wich handle anything for the Actor. Even the actor's own"
" stuff."
msgstr ""

#: ../../source/fsm/how-to-use/setting-up-an-actor.rst:14
msgid ""
"e.g. you can have a component that handles the movement of the actor, and"
" another that handles the animation of the actor. Both of them will have "
"references within the actor's script, and therefore any of the actor's "
"states can access them."
msgstr ""

#: ../../source/fsm/how-to-use/setting-up-an-actor.rst:28
msgid ""
"You can have as many actors representations as you wish in your game. "
"Being the class :ref:`Actor <actor-class>` an abstraction, just implement"
" classes wich inherit from the :ref:`Actor <actor-class>` class."
msgstr ""

#: ../../source/fsm/how-to-use/setting-up-an-actor.rst:32
#: ../../source/fsm/welcome.rst:29
msgid "How it Works"
msgstr ""

#: ../../source/fsm/how-to-use/setting-up-an-actor.rst:34
msgid ""
"At its ``MonoBehaviour.Awake()`` the :ref:`Actor <actor-class>` will try "
"finding a :ref:`StateMachine <state-machine-class>` component among "
"either its own GameObject or its children GameObjects."
msgstr ""

#: ../../source/fsm/how-to-use/setting-up-an-actor.rst:37
msgid ""
"From there on the Machine will auto regulate the actor's states "
"evaluating if it needs transitioning into another state on each of the "
"actor's ``MonoBehaviour.Update()`` ``MonoBehaviour.FixedUpdate()`` and "
"``MonoBehaviour.LateUpdate()`` methods execution."
msgstr ""

#: ../../source/fsm/how-to-use/setting-up-an-actor.rst:42
msgid "MonoBehaviour Tickers"
msgstr ""

#: ../../source/fsm/how-to-use/setting-up-an-actor.rst:44
msgid ""
"At each of the Actor's MonoBehaviour \"frame handlers\" it will call the "
"Machine's corresponding ticker. The machine will then call its current "
"state corresponding Ticker method."
msgstr ""

#: ../../source/fsm/how-to-use/setting-up-an-actor.rst:47
msgid ""
"This means that all states will be synced with the actor's MonoBehaviour "
"methods. Therefore we can say all action's execution are isolated inside "
"the state respecting the actor's pacing."
msgstr ""

#: ../../source/fsm/how-to-use/setting-up-an-actor.rst:51
msgid "The Code"
msgstr ""

#: ../../source/fsm/how-to-use/setting-up-an-actor.rst:53
msgid ""
"Below is a good start for creating an :ref:`Actor <actor-class>` script "
"of your own. Feel free to copy:"
msgstr ""

#: ../../source/fsm/how-to-use/setting-up-an-actor.rst:57
msgid ""
"Be aware that you need calling the base class methods in case of "
"overrides of the core ``MonoBehaviour`` methods (wich will probably be "
"needed)."
msgstr ""

#: ../../source/fsm/how-to-use/setting-up-an-actor.rst:102
msgid ""
"You can also right click on a folder of your Unity Editor's project "
"window and follow the path *Create* ``->`` *IndieGabo* ``->`` *FSM* "
"``->`` *New Actor*. Selecting this will create a new ``Actor`` script "
"under the right clicked folder for you (Make sure you have the package "
"installed)."
msgstr ""

#: ../../source/fsm/how-to-use/setting-up-an-actor.rst:-1
#: ../../source/fsm/how-to-use/using-the-state-machine.rst:-1
msgid "Creating actor script from menu"
msgstr ""

#: ../../source/fsm/how-to-use/setting-up-an-actor.rst:109
msgid ""
"Hurray! You've just created your first Actor! Congratulations! Time to "
"understand how to create states for your Actor by :ref:`clicking here "
"<creating-states-for-an-actor-page>`."
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:4
msgid "Using the state machine"
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:7
msgid "Behold: THE STATE MACHINE!!!"
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:9
msgid ""
"Now that we know how to :ref:`setup an a actor <setting-up-an-actor-"
"class>` and how to :ref:`create its states <creating-states-for-an-actor-"
"page>` we can finally use the state machine."
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:12
msgid ""
"The :ref:`StateMachine <state-machine-class>` component, different from "
"the actors and states, is a ready to use component. So you do not need to"
" worry about creating any script for it. Just attach to a GameObject, "
"attach states to the same GameObject, set a default state and you are "
"good to go."
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:15
msgid ""
"But, if you want to understand a little about it// Some other code Let's "
"do it!"
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:20
msgid "Life Cycle"
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:22
msgid "Let's take a look at the machine's Life Cycle:"
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:30
msgid ""
"The ``StateMachine`` at its current version has 5 statuses: ``Off``, "
"``Loading``, ``Ready``, ``On`` and ``Paused``. They are declared as the "
"enum ``IndieGabo.FSM.MachineStatus``."
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:33
msgid "I'd like to focus some attention on these steps:"
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:35
msgid "The machine first ``StateMachine.status`` is ``MachineStatus.Off``."
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:37
msgid ""
"Note that although our machine belongs to MonoBehaviour, it is the "
":ref:`Actor <actor-class>` wich sets up the machine. That is because the "
"machine can only start operating when the actor is already awake. Once "
"Awake, the actor calls ``StateMachine.SetUp()`` letting it know who its "
"actor is."
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:41
msgid ""
"At this point the machine will change ``StateMachine.status`` from "
"``MachineStatus.Off`` to ``MachineStatus.Loading``."
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:43
msgid ""
"Here the machine will load up all the states attached into its GameObject"
" and call subsequently all of the attached states ``State.OnLoad()`` "
"followed by their ``State.SortTransitions()``. This last method makes "
"sure transitions priorities get in order. This is the importancy of "
"registering any :ref:`StateTranstion <state-transition-class>` of your "
"state inside its ``State.OnLoad()``."
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:47
msgid ""
"Now the machine will change ``StateMachine.status`` from "
"``MachineStatus.Loading`` to ``MachineStatus.Ready``."
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:49
msgid ""
"Once ready, the machine will start by using "
"``StateMachine.ChangeState()`` to set the chosen default state (At the "
"inspector. By you. Do not forget to do it)."
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:52
msgid ""
"The machine will finally change ``StateMachine.status`` from "
"``MachineStatus.Ready`` to ``MachineStatus.On`` and it is running!!! "
"Hurray!"
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:55
msgid "Tickers Methods and Machine Statuses"
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:57
msgid ""
"Once the machine has started, meaning its ``StateMachine.status`` is "
"``MachineStatus.On``, it will proceed passing forward the tickers methods"
" (called inside the actor's \"frame handlers\") to the current state. As "
"long as the ``StateMachine.status`` is ``MachineStatus.On`` it will do "
"so."
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:60
msgid ""
"If at any time you need to pause this behaviour, you can call "
"``StateMachine.Pause()`` and it will set ``StateMachine.status`` to "
"``MachineStatus.Paused``. Consequently, none of the tickers will be "
"passed forward to the current state, therefore we can considered it as "
"paused."
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:74
msgid ""
"To unpause, simply call ``StateMachine.Resume()`` and the "
"``StateMachine.status`` will be ``MachineStatus.On`` again."
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:88
msgid "Setting up the machine"
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:90
msgid ""
"You can simply create a single GameObject and attach the "
":ref:`StateMachine <state-machine-class>` component into it. Same goes "
"for the :ref:`Actor <actor-class>`. Take a look:"
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:101
msgid ""
"But, as the actor's GameObject tends to have multiple components attached"
" into it, for the sake of organization, i find more convenient to proceed"
" creating an GameObject for the actor and use the machine as its child. "
"Check it out:"
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:112
msgid "Both strategies will work transparently for you. Just choose yours."
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:114
msgid ""
"As you could observe, i've prepared a menu item for you to put a new "
"state machine into your hierarchy. But if you wish to attach the "
":ref:`StateMachine <state-machine-class>` component into any GameObject, "
"feel free to search for it using the \"Add Component\" inspector button."
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:118
msgid "All set!"
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:120
msgid ""
"Checkout the API documentation if you want to know more about these "
"classes. For now, i'd say you have all the tools needed to start "
"benefiting from the state machine!"
msgstr ""

#: ../../source/fsm/how-to-use/using-the-state-machine.rst:123
msgid "HURRAY!! Go do something awesome and let me know about it!"
msgstr ""

#: ../../source/fsm/welcome.rst:4
msgid "FSM"
msgstr ""

#: ../../source/fsm/welcome.rst:6
msgid "Much welcome to the IndieGabo's FSM!"
msgstr ""

#: ../../source/fsm/welcome.rst:8
msgid ""
"This is a code driven FSM (Finate State Machine) solution for your Unity "
"project."
msgstr ""

#: ../../source/fsm/welcome.rst:11
msgid "What is a Finite State Machine?"
msgstr ""

#: ../../source/fsm/welcome.rst:13
msgid ""
"A Finate State Machine is a design pattern focused on dealing with "
"entities that have multiple possible states."
msgstr ""

#: ../../source/fsm/welcome.rst:16
msgid "Why this FSM?"
msgstr ""

#: ../../source/fsm/welcome.rst:18
msgid ""
"Although we know Unity's Animator is a StateMachine it can get messy to "
"use it as a functionality handler. This FSM helps you to organizing your "
"code by holding the actors actions logic inside its respective state (we "
"will talk about actors in a bit)."
msgstr ""

#: ../../source/fsm/welcome.rst:21
msgid "Key pratical benefits of using this FSM:"
msgstr ""

#: ../../source/fsm/welcome.rst:23
msgid "Helps you keep things organized"
msgstr ""

#: ../../source/fsm/welcome.rst:24
msgid ""
"Once you understand how it works it'll save you hours of debugging since "
"you will know exactly where each functionality is being executed"
msgstr ""

#: ../../source/fsm/welcome.rst:25
msgid ""
"Avoids overload of unecessary if statements since each state will only "
"check for the conditions based on their registered transitions"
msgstr ""

#: ../../source/fsm/welcome.rst:26
msgid "You can get it running in like 5 minutes"
msgstr ""

#: ../../source/fsm/welcome.rst:31
msgid ""
"Take the concept of an ``actor`` being anything on your game wich "
"performs several actions. The ``state machine`` then is setup to rule a "
"given ``actor`` states of actions. The ``actor`` states must be "
"registered into the ``state machine`` being that a ``state`` knows when "
"to transition into another ``state`` under specific conditions."
msgstr ""

#: ../../source/fsm/welcome.rst:35
msgid ""
"Also, for the usage of this FSM, we consider that a ``state`` isn't just "
"some kind of status or definition. Our states **actually handles** what "
"its ``actor`` performs while on a given ``state`` of actions."
msgstr ""

#: ../../source/fsm/welcome.rst:39
msgid "How to use"
msgstr ""

#: ../../source/fsm/welcome.rst:50
msgid "API"
msgstr ""

